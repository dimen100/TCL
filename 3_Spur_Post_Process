import os
import pandas as pd
import re
import numpy as np

# Define the main path
directory = r'C:\Users\ABC\Desktop'

# List to store rows of data from all processed files
consolidated_data = []

# Flag to control conversion to linear terms
convert_to_linear = True  # Set to False if you want to keep dBm and dBc values


# Function to convert dBm to linear (mW)
def dbm_to_linear(dbm):
    return 10 ** (dbm / 10.0)


# Function to convert dBc to linear
def dbc_to_linear(dbc):
    return 10 ** (dbc / 10.0)


# Function to extract peak power for target frequencies from the file name
def extract_peak_power(df, target_frequencies, tolerance=1.0):
    picked_data = []
    for freq in target_frequencies:
        # Find the closest frequency within the tolerance range
        within_tolerance = df[(df['Peak Frequency (MHz)'] - freq).abs() < tolerance]
        if not within_tolerance.empty:
            closest_index = (within_tolerance['Peak Frequency (MHz)'] - freq).abs().idxmin()
            peak_amplitude_dbm = df.loc[closest_index, 'Peak Amplitude (dBm)']
            # Convert to linear if the flag is on
            if convert_to_linear:
                peak_amplitude = dbm_to_linear(peak_amplitude_dbm)
            else:
                peak_amplitude = peak_amplitude_dbm
            picked_data.append(peak_amplitude)
        else:
            picked_data.append('No Match Found')
    return picked_data


# Function to parse frequencies and values from the file name
def parse_frequencies_and_values_from_filename(filename):
    # Replace 'p' with '.' to handle decimal point
    filename = filename.replace('p', '.')

    # Extract numbers from the filename
    freq_matches = re.findall(r'\d+\.?\d*', filename)

    # The first value extracted after 'Data' is the value before frequencies
    first_value = freq_matches[0] if freq_matches else None

    # Extract target frequencies (only those >= 100 MHz)
    target_frequencies = [float(f) for f in freq_matches if float(f) >= 100]

    return first_value, target_frequencies


# Function to find and return the largest spur while ignoring main tones with tolerance
def find_largest_spur(df, main_tones, tolerance=1.0):
    # Exclude rows where the 'Peak Frequency (MHz)' is within the tolerance range of any main tone
    spurs = df[~df['Peak Frequency (MHz)'].apply(lambda x: any(abs(x - tone) < tolerance for tone in main_tones))]

    # If spurs exist after filtering, find the largest one
    if not spurs.empty:
        largest_spur = spurs.loc[spurs['Peak Amplitude (dBm)'].idxmax()]
        spur_freq = largest_spur['Peak Frequency (MHz)']
        spur_amp_dbm = largest_spur['Peak Amplitude (dBm)']
        # Convert to linear if the flag is on
        if convert_to_linear:
            spur_amp = dbm_to_linear(spur_amp_dbm)
        else:
            spur_amp = spur_amp_dbm
    else:
        spur_freq = 'No Spur'
        spur_amp = 'No Spur'

    return spur_freq, spur_amp


# Function to append data to the consolidated list
def append_to_consolidated_data(first_value, target_frequencies, peak_data, spur_freq, spur_amp, temp, time):
    # Create a structured row without headers or units
    data_row = [first_value] + target_frequencies + peak_data + [spur_freq, spur_amp, temp, time]
    consolidated_data.append(data_row)


# Variable to store the directory for the output file
output_directory = None

# Navigate through the main path and its subfolders
for root, dirs, files in os.walk(directory):
    if 'TCL' in root:
        for file in files:
            if file.endswith('.csv'):
                file_path = os.path.join(root, file)

                # Load the CSV data into a DataFrame
                df = pd.read_csv(file_path)

                # Sort the data by 'Peak Frequency (MHz)'
                df_sorted = df.sort_values('Peak Frequency (MHz)')

                # Parse the first value and target frequencies from the file name
                first_value, target_frequencies = parse_frequencies_and_values_from_filename(file)

                # Extract peak data for the parsed frequencies
                peak_data = extract_peak_power(df_sorted, target_frequencies)

                # Find the largest spur
                spur_freq, spur_amp = find_largest_spur(df_sorted, target_frequencies)

                # Extract Temp and Time from the CSV file (taking the first row as an example)
                temp = df_sorted['Temp (C)'].iloc[0]
                time = df_sorted['Time'].iloc[0]

                # Append the data to the consolidated list
                append_to_consolidated_data(first_value, target_frequencies, peak_data, spur_freq, spur_amp, temp, time)

                # Set the output directory based on the first CSV file location
                if output_directory is None:
                    output_directory = root

# Once all files are processed, save the consolidated data into a single CSV in the same directory
if output_directory:
    output_csv_path = os.path.join(output_directory, 'Consolidated_Output.csv')

    # Convert the consolidated data to a DataFrame and save it to a CSV without headers
    consolidated_df = pd.DataFrame(consolidated_data)
    consolidated_df.to_csv(output_csv_path, index=False, header=False)
    print(f"Consolidated data saved to {output_csv_path}")
else:
    print("No CSV files found to process.")
